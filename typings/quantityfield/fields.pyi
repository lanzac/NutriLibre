"""
This type stub file was generated by pyright.
"""

import datetime
import typing
from django import forms
from django.db import models
from decimal import Decimal
from pint import Quantity
from typing import Any, Callable, Dict, List, Optional, Sequence, Tuple, Union

DJANGO_JSON_SERIALIZABLE_BASE = Union[None, bool, str, int, float, complex, datetime.datetime]
DJANGO_JSON_SERIALIZABLE = Union[Sequence[DJANGO_JSON_SERIALIZABLE_BASE], Dict[str, DJANGO_JSON_SERIALIZABLE_BASE]]
NUMBER_TYPE = Union[int, float, Decimal]
class QuantityFieldMixin:
    to_number_type: Callable[[Any], NUMBER_TYPE]
    value_from_object: Callable[[Any], Any]
    name: str
    validate: Callable
    run_validators: Callable
    def __init__(self, base_units: str, *args, unit_choices: Optional[typing.Iterable[str]] = ..., **kwargs) -> None:
        """
        Create a Quantity field
        :param base_units: Unit description of base unit
        :param unit_choices: If given the possible unit choices with the same
                             dimension like the base_unit
        """
        ...
    
    @property
    def units(self) -> str:
        ...
    
    def deconstruct(self) -> Tuple[str, str, Sequence[DJANGO_JSON_SERIALIZABLE], Dict[str, DJANGO_JSON_SERIALIZABLE],]:
        """
        Return enough information to recreate the field as a 4-tuple:

         * The name of the field on the model, if contribute_to_class() has
           been run.
         * The import path of the field, including the class:e.g.
           django.db.models.IntegerField This should be the most portable
           version, so less specific may be better.
         * A list of positional arguments.
         * A dict of keyword arguments.

        """
        ...
    
    def fix_unit_registry(self, value: Quantity) -> Quantity:
        """
        Check if the UnitRegistry from settings is used.
        If not try to fix it but give a warning.
        """
        ...
    
    def get_prep_value(self, value: Any) -> Optional[NUMBER_TYPE]:
        """
        Perform preliminary non-db specific value checks and conversions.

        Make sure that we compare/use only values without a unit
        """
        ...
    
    def value_to_string(self, obj) -> str:
        ...
    
    def from_db_value(self, value: Any, *args, **kwargs) -> Optional[Quantity]:
        ...
    
    def to_python(self, value) -> Optional[Quantity]:
        ...
    
    def clean(self, value, model_instance) -> Quantity:
        """
        Convert the value's type and run validation. Validation errors
        from to_python() and validate() are propagated. Return the correct
        value if no error is raised.

        This is a copy from djangos implementation but modified so that validators
        are only checked against the magnitude as otherwise the default database
        validators will not fail because of comparison errors
        """
        ...
    
    def formfield(self, **kwargs):
        ...
    


class QuantityFormFieldMixin:
    """This formfield allows a user to choose which units they
    wish to use to enter a value, but the value is yielded in
    the base_units
    """
    to_number_type: Callable[[Any], NUMBER_TYPE]
    validate: Callable
    run_validators: Callable
    error_messages: Dict[str, str]
    empty_values: Sequence[Any]
    localize: bool
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def prepare_value(self, value): # -> PlainQuantity[Any]:
        ...
    
    def clean(self, value): # -> PlainQuantity[Any] | Any | None:
        """
        General idea, first try to extract the correct number like done in the other
        classes and then follow the same procedure as in the django default field
        """
        ...
    


class QuantityFormField(QuantityFormFieldMixin, forms.FloatField):
    to_number_type = float


class QuantityField(QuantityFieldMixin, models.FloatField):
    form_field_class = QuantityFormField
    to_number_type = float


class IntegerQuantityFormField(QuantityFormFieldMixin, forms.IntegerField):
    to_number_type = int


class IntegerQuantityField(QuantityFieldMixin, models.IntegerField):
    form_field_class = IntegerQuantityFormField
    to_number_type = int


class BigIntegerQuantityField(QuantityFieldMixin, models.BigIntegerField):
    form_field_class = IntegerQuantityFormField
    to_number_type = int


class PositiveIntegerQuantityField(QuantityFieldMixin, models.PositiveIntegerField):
    form_field_class = IntegerQuantityFormField
    to_number_type = int


class DecimalQuantityFormField(QuantityFormFieldMixin, forms.DecimalField):
    to_number_type = Decimal


class DecimalQuantityField(QuantityFieldMixin, models.DecimalField):
    form_field_class = DecimalQuantityFormField
    to_number_type = Decimal
    def __init__(self, base_units: str, *args, unit_choices: Optional[List[str]] = ..., verbose_name: str = ..., name: str = ..., max_digits: int = ..., decimal_places: int = ..., **kwargs) -> None:
        ...
    
    def get_db_prep_save(self, value, connection) -> Decimal:
        """
        Get Value that shall be saved to database, make sure it is transformed
        """
        ...
    


